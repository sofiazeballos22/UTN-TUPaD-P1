# ğŸ” PrÃ¡ctico 11 - Recursividad en Python

Este proyecto fue desarrollado de forma individual como parte del trabajo prÃ¡ctico de **ProgramaciÃ³n I** en la **UTN - TUPaD**, dentro de la carpeta `11 Recursividad`.

El objetivo del trabajo fue **aplicar recursividad en la resoluciÃ³n de problemas**, entendiendo su lÃ³gica y comportamiento. Se incluyeron **validaciones de entrada, manejo de errores y separaciÃ³n de responsabilidades**, estructurando el cÃ³digo de forma reutilizable y profesional.

---

## ğŸ¯ DescripciÃ³n General

Se desarrollaron funciones recursivas para resolver distintas problemÃ¡ticas matemÃ¡ticas y algorÃ­tmicas.  
El cÃ³digo fue dividido en dos archivos:

- `recursividad.py`: contiene las funciones puras y validadas
- `main.py`: ejecuta ejemplos prÃ¡cticos de cada funciÃ³n

Esta separaciÃ³n permite **reutilizar la lÃ³gica** en otros programas o incluso en futuros desarrollos con interfaz grÃ¡fica o tests automÃ¡ticos.

---

##  Funcionalidades principales

- âœ… ImplementaciÃ³n de funciones recursivas puras
- ğŸ›¡ï¸ Validaciones estrictas con `ValueError` ante entradas invÃ¡lidas
- ğŸ“‹ SeparaciÃ³n de lÃ³gica (`recursividad.py`) y pruebas (`main.py`)
- ğŸ”¢ Manejo de errores con `try/except`
- ğŸ§© AplicaciÃ³n prÃ¡ctica de recursividad con ejemplos reales

---

## ğŸ”§ Herramientas y tÃ©cnicas utilizadas

### ğŸ“š Funciones y estructuras principales (con nÃºmero de lÃ­nea aproximado):

| LÃ­nea | FunciÃ³n | DescripciÃ³n |
|-------|---------|-------------|
| 5     | `factorial(n)` | Calcula el factorial de un nÃºmero entero positivo |
| 13    | `fibonacci(pos)` | Retorna el valor de la serie de Fibonacci en una posiciÃ³n dada |
| 21    | `potencia(base, exponente)` | Calcula base elevado a exponente de forma recursiva |
| 27    | `decimal_a_binario(n)` | Convierte un nÃºmero decimal a binario como string |
| 33    | `es_palindromo(palabra)` | Verifica si una palabra es un palÃ­ndromo |
| 40    | `suma_digitos(n)` | Suma los dÃ­gitos de un nÃºmero entero sin convertir a string |
| 46    | `contar_bloques(n)` | Calcula bloques necesarios para una pirÃ¡mide de altura `n` |
| 51    | `contar_digito(numero, digito)` | Cuenta cuÃ¡ntas veces aparece un dÃ­gito dentro de un nÃºmero |

---

## ğŸ’¡ Palabras clave y conceptos utilizados

- `recursiÃ³n`: funciÃ³n que se llama a sÃ­ misma
- `if / else`: estructuras de control
- `raise ValueError(...)`: para forzar errores ante entradas invÃ¡lidas
- `isinstance()`: validaciÃ³n del tipo de dato
- `try / except`: manejo de errores en ejecuciÃ³n
- `modularizaciÃ³n`: separar la lÃ³gica de ejecuciÃ³n

---

## ğŸ“¦ Estructura del proyecto

11 Recursividad/
â”œâ”€â”€ recursividad.py # LÃ³gica pura: funciones recursivas validadas
â”œâ”€â”€ main.py # Pruebas y llamadas a funciones
â””â”€â”€ README.md # DocumentaciÃ³n del proyecto



---

## ğŸ“Œ Requisitos

- Python 3.x
- Editor como VSCode, Thonny o PyCharm
- Consola o terminal para ejecutar `main.py`

---

## ğŸ§ª Ejemplo de flujo

**EjecuciÃ³n en consola:**

```bash
python main.py


 1) Factorial de 5: 120
 2) Serie Fibonacci hasta posiciÃ³n 7:
Fibonacci(0) = 0
Fibonacci(1) = 1
...
Fibonacci(7) = 13
 3) Potencia 2^4: 16
 4) Decimal 13 a binario: 1101
 5) Â¿Es 'radar' un palÃ­ndromo?: True
 6) Suma de dÃ­gitos de 1234: 10
 7) Bloques para pirÃ¡mide de altura 4: 10
 8) El dÃ­gito 3 aparece 3 veces en 31353


## ğŸ™Œ CrÃ©ditos

Proyecto realizado por **Ana SofÃ­a Zeballos, comisiÃ³n 5** *   
Trabajo prÃ¡ctico de **ProgramaciÃ³n I - UTN TUPaD**  
Tema: Tema: AplicaciÃ³n de funciones recursivas en Python
